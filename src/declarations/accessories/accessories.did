type Value = 
 variant {
   Bool: bool;
   Class: vec Property;
   Empty;
   Float: float64;
   Int: int;
   Nat: nat;
   Principal: principal;
   Text: text;
 };
type User = 
 variant {
   address: AccountIdentifier__1;
   "principal": principal;
 };
type TokenIndex = nat32;
type TokenIdentifier__1 = text;
type TokenIdentifier = text;
type Template = 
 variant {
   Accessory: record {
                after_wear: text;
                before_wear: text;
                recipe: Recipe;
              };
   LegendaryAccessory: blob;
   Material: blob;
 };
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback: StreamingCallback;
                              token: StreamingCallbackToken;
                            };};
type StreamingCallbackToken = 
 record {
   content_encoding: text;
   index: nat;
   key: text;
 };
type StreamingCallbackResponse = 
 record {
   body: blob;
   token: opt StreamingCallbackToken;
 };
type StreamingCallback = func (StreamingCallbackToken) ->
                          (StreamingCallbackResponse) query;
type Result_8 = 
 variant {
   err: text;
   ok: text;
 };
type Result_7 = 
 variant {
   err: CommonError__1;
   ok: AccountIdentifier;
 };
type Result_6 = 
 variant {
   err: CommonError;
   ok: Metadata;
 };
type Result_5 = 
 variant {
   err: Error;
   ok: text;
 };
type Result_4 = 
 variant {
   err: Error;
   ok: principal;
 };
type Result_3 = 
 variant {
   err: Error;
   ok: PublicToken;
 };
type Result_2 = 
 variant {
   err: Error;
   ok: nat64;
 };
type Result_1 = 
 variant {
   err: Error;
   ok;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type Response = 
 record {
   body: blob;
   headers: vec HeaderField;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
 };
type Request = 
 record {
   body: blob;
   headers: vec HeaderField;
   method: text;
   url: text;
 };
type Recipe = vec text;
type PublicToken = 
 record {
   contentType: text;
   createdAt: int;
   id: text;
   owner: principal;
   payload: PayloadResult;
   properties: Properties;
 };
type Property = 
 record {
   immutable: bool;
   name: text;
   value: Value;
 };
type Properties = vec Property;
type PayloadResult = 
 variant {
   Chunk: Chunk;
   Complete: blob;
 };
type Metadata = 
 variant {
   fungible:
    record {
      decimals: nat8;
      metadata: opt blob;
      name: text;
      symbol: text;
    };
   nonfungible: record {metadata: opt blob;};
 };
type Inventory = vec AssetInventory;
type Hub = 
 service {
   addElements: (text, Template) -> (Result_8);
   airdrop: (AirdropObject) -> (Result);
   balance: (BalanceRequest) -> (BalanceResponse) query;
   balanceOf: (principal) -> (vec text) query;
   bearer: (TokenIdentifier) -> (Result_7) query;
   circulationToItem: () -> ();
   departureToExt: () -> ();
   extensions: () -> (vec Extension) query;
   getContractInfo: () -> (ContractInfo);
   getHisInventory: (principal) -> (Inventory) query;
   getHisInventory_new: (principal) -> (Inventory) query;
   getInventory: () -> (Inventory) query;
   getMaterials: (principal) -> (vec text) query;
   getMetadata: () -> (ContractMetadata) query;
   getMinter: () -> (vec principal) query;
   getOwnership: () -> (vec record {
                              AccountIdentifier;
                              vec TokenIndex;
                            }) query;
   getRegistry: () -> (vec record {
                             TokenIndex;
                             AccountIdentifier;
                           }) query;
   getTotalMinted: () -> (nat) query;
   howMany: (text) -> (nat) query;
   http_request: (Request) -> (Response) query;
   init: (vec principal, ContractMetadata) -> ();
   init_cap: () -> (Result);
   metadata: (TokenIdentifier) -> (Result_6) query;
   mint: (text, principal) -> (Result_5);
   ownerOf: (text) -> (Result_4) query;
   showAdmins: () -> (vec principal) query;
   sizes: () -> (nat, nat) query;
   supply: () -> (nat) query;
   tokenByIndex: (text) -> (Result_3);
   transfer: (principal, text) -> (Result_2);
   updateAccessories: () -> ();
   updateAdmins: (principal, bool) -> (Result_1);
   wallet_available: () -> (nat) query;
   wallet_receive: () -> ();
   wearAccessory: (text, text) -> (Result);
 };
type HeaderField = 
 record {
   text;
   text;
 };
type Extension = text;
type Error = 
 variant {
   AssetNotFound;
   AssetTooHeavy;
   AuthorizedPrincipalLimitReached: nat;
   ErrorMinting;
   FailedToWrite: text;
   Immutable;
   InvalidRequest;
   NotFound;
   Unauthorized;
   invalidTransaction;
   unsupportedResponse;
 };
type ContractMetadata = 
 record {
   name: text;
   symbol: text;
 };
type ContractInfo = 
 record {
   authorized_users: vec principal;
   cycles: nat;
   heap_size: nat;
   max_live_size: nat;
   memory_size: nat;
   nft_payload_size: nat;
   total_minted: nat;
 };
type CommonError__1 = 
 variant {
   InvalidToken: TokenIdentifier__1;
   Other: text;
 };
type CommonError = 
 variant {
   InvalidToken: TokenIdentifier__1;
   Other: text;
 };
type Chunk = 
 record {
   data: blob;
   nextPage: opt nat;
   totalPages: nat;
 };
type BalanceResponse = 
 variant {
   err: CommonError;
   ok: Balance;
 };
type BalanceRequest = 
 record {
   token: TokenIdentifier__1;
   user: User;
 };
type Balance = nat;
type AssetInventoryType = 
 variant {
   Accessory;
   LegendaryAccessory;
   Material;
 };
type AssetInventory = 
 record {
   category: AssetInventoryType;
   name: text;
   token_identifier: text;
 };
type AirdropObject = 
 record {
   accessory1: opt text;
   accessory2: opt text;
   material: text;
   recipient: principal;
 };
type AccountIdentifier__1 = text;
type AccountIdentifier = text;
service : () -> Hub
