type User = 
 variant {
   address: AccountIdentifier;
   "principal": principal;
 };
type UpdateCallsAggregatedData = vec nat64;
type TransferResult = 
 variant {
   Err: TransferError;
   Ok: BlockIndex;
 };
type TransferResponse = 
 variant {
   err:
    variant {
      CannotNotify: AccountIdentifier;
      InsufficientBalance;
      InvalidToken: TokenIdentifier;
      Other: text;
      Rejected;
      Unauthorized: AccountIdentifier;
    };
   ok: Balance;
 };
type TransferRequest = 
 record {
   amount: Balance;
   from: User;
   memo: Memo;
   notify: bool;
   subaccount: opt SubAccount;
   to: User;
   token: TokenIdentifier;
 };
type TransferError = 
 variant {
   BadFee: record {expected_fee: ICP;};
   InsufficientFunds: record {balance: ICP;};
   TxCreatedInFuture;
   TxDuplicate: record {duplicate_of: BlockIndex;};
   TxTooOld: record {allowed_window_nanos: nat64;};
 };
type Transaction = 
 record {
   buyer: AccountIdentifier__1;
   price: nat64;
   seller: principal;
   time: Time;
   token: TokenIdentifier__1;
 };
type TokenIndex = nat32;
type TokenIdentifier__3 = text;
type TokenIdentifier__2 = text;
type TokenIdentifier__1 = text;
type TokenIdentifier = text;
type Time = int;
type Template = 
 variant {
   Accessory: record {
                after_wear: text;
                before_wear: text;
                recipe: Recipe__1;
              };
   LegendaryAccessory: blob;
   Material: blob;
 };
type SubAccount__2 = vec nat8;
type SubAccount__1 = vec nat8;
type SubAccount = vec nat8;
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback: StreamingCallback;
                              token: StreamingCallbackToken;
                            };};
type StreamingCallbackToken = 
 record {
   content_encoding: text;
   index: nat;
   key: text;
 };
type StreamingCallbackResponse = 
 record {
   body: blob;
   token: opt StreamingCallbackToken;
 };
type StreamingCallback = func (StreamingCallbackToken) ->
                          (StreamingCallbackResponse) query;
type Settlement = 
 record {
   buyer: AccountIdentifier__1;
   price: nat64;
   seller: principal;
   subaccount: SubAccount__2;
 };
type Result_7 = 
 variant {
   err: text;
   ok: text;
 };
type Result_6 = 
 variant {
   err: text;
   ok: TokenIdentifier__3;
 };
type Result_5 = 
 variant {
   err: CommonError;
   ok: AccountIdentifier__2;
 };
type Result_4 = 
 variant {
   err: CommonError__1;
   ok: Metadata;
 };
type Result_3 = 
 variant {
   err: CommonError;
   ok;
 };
type Result_2 = 
 variant {
   err: CommonError;
   ok: vec record {
             TokenIndex;
             opt Listing;
             opt blob;
           };
 };
type Result_1 = 
 variant {
   err: Error;
   ok;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type Response = 
 record {
   body: blob;
   headers: vec HeaderField;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
 };
type Request = 
 record {
   body: blob;
   headers: vec HeaderField;
   method: text;
   url: text;
 };
type Recipe__1 = vec text;
type Recipe = vec text;
type Option = bool;
type NumericEntity = 
 record {
   avg: nat64;
   first: nat64;
   last: nat64;
   max: nat64;
   min: nat64;
 };
type MetricsGranularity = 
 variant {
   daily;
   hourly;
 };
type Metadata__1 = 
 variant {
   fungible:
    record {
      decimals: nat8;
      metadata: opt blob;
      name: text;
      symbol: text;
    };
   nonfungible: record {metadata: opt blob;};
 };
type Metadata = 
 variant {
   fungible:
    record {
      decimals: nat8;
      metadata: opt blob;
      name: text;
      symbol: text;
    };
   nonfungible: record {metadata: opt blob;};
 };
type Memo = blob;
type Listing = 
 record {
   locked: opt Time;
   price: nat64;
   seller: principal;
 };
type ListRequest = 
 record {
   from_subaccount: opt SubAccount__2;
   price: opt nat64;
   token: TokenIdentifier__1;
 };
type LegendaryAccessory = 
 record {
   date_creation: int;
   name: text;
 };
type Item = 
 variant {
   Accessory: Accessory;
   LegendaryAccessory: LegendaryAccessory;
   Material: text;
 };
type Inventory = vec AssetInventory;
type ICP = record {e8s: nat64;};
type Hub = 
 service {
   addElements: (text, Template) -> (Result_7);
   airdrop: (AirdropObject) -> (Result);
   allPayments: () -> (vec record {
                             principal;
                             vec SubAccount__1;
                           }) query;
   allSettlements: () -> (vec record {
                                TokenIndex;
                                Settlement;
                              }) query;
   balance: (BalanceRequest) -> (BalanceResponse) query;
   balance_ledger: () -> (ICP);
   bearer: (TokenIdentifier__3) -> (Result_5) query;
   burn: (TokenIdentifier__3) -> (Result);
   circulationSize: () -> (nat) query;
   clearPayments: (principal, vec SubAccount__1) -> ();
   collectCanisterMetrics: () -> ();
   createAccessory: (text, vec TokenIdentifier__3, vec nat8, opt Option) ->
    (Result_6);
   eventsSize: () -> (nat) query;
   extensions: () -> (vec Extension) query;
   fix: (TokenIdentifier__3) -> ();
   getCanisterMetrics: (GetMetricsParameters) -> (opt CanisterMetrics) query;
   getContractInfo: () -> (ContractInfo);
   getHisInventory: (principal) -> (Inventory) query;
   getIdentifier: (TokenIndex) -> (TokenIdentifier__3) query;
   getIndex: (TokenIdentifier__3) -> (TokenIndex);
   getInventory: () -> (Inventory) query;
   getMetadata: () -> (ContractMetadata) query;
   getMinter: () -> (vec principal) query;
   getOwnership: () ->
    (vec record {
           AccountIdentifier__2;
           vec TokenIndex;
         }) query;
   getRecipes: () -> (vec record {
                            text;
                            Recipe;
                          }) query;
   getRegistry: () -> (vec record {
                             TokenIndex;
                             AccountIdentifier__2;
                           }) query;
   getStats: () -> (vec text) query;
   getTokens: () -> (vec record {
                           TokenIndex;
                           Metadata__1;
                         }) query;
   http_request: (Request) -> (Response) query;
   init: (vec principal, ContractMetadata) -> ();
   init_cap: () -> (Result);
   list: (ListRequest) -> (Result_3);
   listings: () -> (vec record {
                          TokenIndex;
                          Listing;
                          Metadata__1;
                        }) query;
   lock: (text, nat64, AccountIdentifier__2, SubAccount__1) -> (Result_5);
   metadata: (TokenIdentifier__3) -> (Result_4) query;
   mint: (text, AccountIdentifier__2) -> (Result);
   modifyRecipe: (text, Recipe) -> (Result);
   nextTokenId: () -> (nat) query;
   nftId: () -> (nat) query;
   nftSize: () -> (nat) query;
   payments: () -> (opt vec SubAccount__1) query;
   process: () -> ();
   removeAccessory: (text, text) -> (Result);
   settle: (text) -> (Result_3);
   settlements: () ->
    (vec record {
           TokenIndex;
           AccountIdentifier__2;
           nat64;
         }) query;
   showAdmins: () -> (vec principal) query;
   showCirculation: (text) -> (opt text) query;
   showItems: (nat32) -> (opt Item) query;
   stats: () -> (nat64, nat64, nat64, nat64, nat, nat, nat) query;
   supply: () -> (nat) query;
   tokens_ext: (AccountIdentifier__2) -> (Result_2) query;
   transactions: () -> (vec Transaction) query;
   transfer: (TransferRequest) -> (TransferResponse);
   transfer_ledger: (ICP, principal) -> (TransferResult);
   updateAccessories: () -> ();
   updateAdmins: (principal, bool) -> (Result_1);
   updateAdminsData: (principal, bool) -> (Result_1);
   verification: () -> ();
   verificationEvents: () -> ();
   wallet_available: () -> (nat) query;
   wallet_receive: () -> ();
   wearAccessory: (text, text) -> (Result);
   whoami: () -> (principal) query;
 };
type HourlyMetricsData = 
 record {
   canisterCycles: CanisterCyclesAggregatedData;
   canisterHeapMemorySize: CanisterHeapMemoryAggregatedData;
   canisterMemorySize: CanisterMemoryAggregatedData;
   timeMillis: int;
   updateCalls: UpdateCallsAggregatedData;
 };
type HeaderField = 
 record {
   text;
   text;
 };
type GetMetricsParameters = 
 record {
   dateFromMillis: nat;
   dateToMillis: nat;
   granularity: MetricsGranularity;
 };
type Extension = text;
type Error = 
 variant {
   AssetNotFound;
   AssetTooHeavy;
   AuthorizedPrincipalLimitReached: nat;
   ErrorMinting;
   FailedToWrite: text;
   Immutable;
   InvalidRequest;
   NotFound;
   Unauthorized;
   invalidTransaction;
   unsupportedResponse;
 };
type DailyMetricsData = 
 record {
   canisterCycles: NumericEntity;
   canisterHeapMemorySize: NumericEntity;
   canisterMemorySize: NumericEntity;
   timeMillis: int;
   updateCalls: nat64;
 };
type ContractMetadata = 
 record {
   name: text;
   symbol: text;
 };
type ContractInfo = 
 record {
   authorized_users: vec principal;
   cycles: nat;
   heap_size: nat;
   max_live_size: nat;
   memory_size: nat;
   nft_payload_size: nat;
   total_minted: nat;
 };
type CommonError__1 = 
 variant {
   InvalidToken: TokenIdentifier;
   Other: text;
 };
type CommonError = 
 variant {
   InvalidToken: TokenIdentifier;
   Other: text;
 };
type CanisterMetricsData = 
 variant {
   daily: vec DailyMetricsData;
   hourly: vec HourlyMetricsData;
 };
type CanisterMetrics = record {data: CanisterMetricsData;};
type CanisterMemoryAggregatedData = vec nat64;
type CanisterHeapMemoryAggregatedData = vec nat64;
type CanisterCyclesAggregatedData = vec nat64;
type BlockIndex = nat64;
type BalanceResponse = 
 variant {
   err: CommonError__1;
   ok: Balance;
 };
type BalanceRequest = 
 record {
   token: TokenIdentifier;
   user: User;
 };
type Balance = nat;
type AssetInventoryType = 
 variant {
   Accessory: bool;
   LegendaryAccessory;
   Material;
 };
type AssetInventory = 
 record {
   category: AssetInventoryType;
   name: text;
   token_identifier: text;
 };
type AirdropObject = 
 record {
   accessory1: opt text;
   accessory2: opt text;
   material: text;
   recipient: principal;
 };
type AccountIdentifier__2 = text;
type AccountIdentifier__1 = text;
type AccountIdentifier = text;
type Accessory = 
 record {
   equipped: opt TokenIdentifier__2;
   name: text;
   wear: nat8;
 };
service : () -> Hub
