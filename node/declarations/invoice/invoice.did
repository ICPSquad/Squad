type VerifyInvoiceSuccess = 
 variant {
   AlreadyVerified: record {invoice: Invoice__1;};
   Paid: record {invoice: Invoice__1;};
 };
type VerifyInvoiceResult = 
 variant {
   err: VerifyInvoiceErr;
   ok: VerifyInvoiceSuccess;
 };
type VerifyInvoiceErr = 
 record {
   kind:
    variant {
      Expired;
      InvalidAccount;
      InvalidInvoiceId;
      InvalidToken;
      NotAuthorized;
      NotFound;
      NotYetPaid;
      Other;
      TransferError;
    };
   message: opt text;
 };
type VerifyInvoiceArgs = record {id: nat;};
type UpdateCallsAggregatedData = vec nat64;
type TransferSuccess = record {blockHeight: nat64;};
type TransferResult = 
 variant {
   err: TransferError;
   ok: TransferSuccess;
 };
type TransferError = 
 record {
   kind:
    variant {
      BadFee;
      InsufficientFunds;
      InvalidDestination;
      InvalidToken;
      Other;
    };
   message: opt text;
 };
type TransferArgs = 
 record {
   amount: nat;
   destination: AccountIdentifier;
   token: Token;
 };
type TokenVerbose = 
 record {
   decimals: int;
   meta: opt record {Issuer: text;};
   symbol: text;
 };
type Token = record {symbol: text;};
type Time = int;
type Permissions = 
 record {
   canGet: vec principal;
   canVerify: vec principal;
 };
type NumericEntity = 
 record {
   avg: nat64;
   first: nat64;
   last: nat64;
   max: nat64;
   min: nat64;
 };
type Nanos = nat64;
type MetricsGranularity = 
 variant {
   daily;
   hourly;
 };
type LogMessagesData = 
 record {
   message: text;
   timeNanos: Nanos;
 };
type Invoice__1 = 
 record {
   amount: nat;
   amountPaid: nat;
   creator: principal;
   destination: AccountIdentifier;
   details: opt Details;
   expiration: Time;
   id: nat;
   paid: bool;
   permissions: opt Permissions;
   token: TokenVerbose;
   verifiedAtTime: opt Time;
 };
type Invoice = 
 service {
   acceptCycles: () -> ();
   accountIdentifierToBlob: (AccountIdentifier__1) ->
    (AccountIdentifierToBlobResult);
   add_admin: (principal) -> ();
   availableCycles: () -> (nat) query;
   collectCanisterMetrics: () -> ();
   create_invoice: (Category) -> (CreateInvoiceResult);
   getCanisterLog: (opt CanisterLogRequest) ->
    (opt CanisterLogResponse) query;
   getCanisterMetrics: (GetMetricsParameters) -> (opt CanisterMetrics) query;
   get_account_identifier: (GetAccountIdentifierArgs) ->
    (GetAccountIdentifierResult) query;
   get_balance: (GetBalanceArgs) -> (GetBalanceResult);
   get_invoice: (GetInvoiceArgs) -> (GetInvoiceResult) query;
   is_admin: (principal) -> (bool) query;
   transfer: (TransferArgs) -> (TransferResult);
   verify_invoice_accessory: (VerifyInvoiceArgs) -> (VerifyInvoiceResult);
   verify_invoice_avatar: (VerifyInvoiceArgs, principal) ->
    (VerifyInvoiceResult);
 };
type HourlyMetricsData = 
 record {
   canisterCycles: CanisterCyclesAggregatedData;
   canisterHeapMemorySize: CanisterHeapMemoryAggregatedData;
   canisterMemorySize: CanisterMemoryAggregatedData;
   timeMillis: int;
   updateCalls: UpdateCallsAggregatedData;
 };
type GetMetricsParameters = 
 record {
   dateFromMillis: nat;
   dateToMillis: nat;
   granularity: MetricsGranularity;
 };
type GetLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   fromTimeNanos: opt Nanos;
 };
type GetLogMessagesFilter = 
 record {
   analyzeCount: nat32;
   messageContains: opt text;
   messageRegex: opt text;
 };
type GetLatestLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   upToTimeNanos: opt Nanos;
 };
type GetInvoiceSuccess = record {invoice: Invoice__1;};
type GetInvoiceResult = 
 variant {
   err: GetInvoiceErr;
   ok: GetInvoiceSuccess;
 };
type GetInvoiceErr = 
 record {
   kind: variant {
           InvalidInvoiceId;
           NotAuthorized;
           NotFound;
           Other;
         };
   message: opt text;
 };
type GetInvoiceArgs = record {id: nat;};
type GetBalanceSuccess = record {balance: nat;};
type GetBalanceResult = 
 variant {
   err: GetBalanceErr;
   ok: GetBalanceSuccess;
 };
type GetBalanceErr = 
 record {
   kind: variant {
           InvalidToken;
           NotFound;
           Other;
         };
   message: opt text;
 };
type GetBalanceArgs = record {token: Token;};
type GetAccountIdentifierSuccess = record {
                                     accountIdentifier: AccountIdentifier;};
type GetAccountIdentifierResult = 
 variant {
   err: GetAccountIdentifierErr;
   ok: GetAccountIdentifierSuccess;
 };
type GetAccountIdentifierErr = 
 record {
   kind: variant {
           InvalidToken;
           Other;
         };
   message: opt text;
 };
type GetAccountIdentifierArgs = 
 record {
   "principal": principal;
   token: Token;
 };
type Details = 
 record {
   description: text;
   meta: blob;
 };
type DailyMetricsData = 
 record {
   canisterCycles: NumericEntity;
   canisterHeapMemorySize: NumericEntity;
   canisterMemorySize: NumericEntity;
   timeMillis: int;
   updateCalls: nat64;
 };
type CreateInvoiceSuccess = record {invoice: Invoice__1;};
type CreateInvoiceResult = 
 variant {
   err: CreateInvoiceErr;
   ok: CreateInvoiceSuccess;
 };
type CreateInvoiceErr = 
 record {
   kind:
    variant {
      BadSize;
      InvalidAmount;
      InvalidDestination;
      InvalidDetails;
      InvalidToken;
      MaxInvoicesReached;
      Other;
    };
   message: opt text;
 };
type Category = 
 variant {
   AccessoryFee;
   AvatarMint;
 };
type CanisterMetricsData = 
 variant {
   daily: vec DailyMetricsData;
   hourly: vec HourlyMetricsData;
 };
type CanisterMetrics = record {data: CanisterMetricsData;};
type CanisterMemoryAggregatedData = vec nat64;
type CanisterLogResponse = 
 variant {
   messages: CanisterLogMessages;
   messagesInfo: CanisterLogMessagesInfo;
 };
type CanisterLogRequest = 
 variant {
   getLatestMessages: GetLatestLogMessagesParameters;
   getMessages: GetLogMessagesParameters;
   getMessagesInfo;
 };
type CanisterLogMessagesInfo = 
 record {
   count: nat32;
   features: vec opt CanisterLogFeature;
   firstTimeNanos: opt Nanos;
   lastTimeNanos: opt Nanos;
 };
type CanisterLogMessages = 
 record {
   data: vec LogMessagesData;
   lastAnalyzedMessageTimeNanos: opt Nanos;
 };
type CanisterLogFeature = 
 variant {
   filterMessageByContains;
   filterMessageByRegex;
 };
type CanisterHeapMemoryAggregatedData = vec nat64;
type CanisterCyclesAggregatedData = vec nat64;
type AccountIdentifier__1 = 
 variant {
   "blob": blob;
   "principal": principal;
   "text": text;
 };
type AccountIdentifierToBlobSuccess = blob;
type AccountIdentifierToBlobResult = 
 variant {
   err: AccountIdentifierToBlobErr;
   ok: AccountIdentifierToBlobSuccess;
 };
type AccountIdentifierToBlobErr = 
 record {
   kind: variant {
           InvalidAccountIdentifier;
           Other;
         };
   message: opt text;
 };
type AccountIdentifier = 
 variant {
   "blob": blob;
   "principal": principal;
   "text": text;
 };
service : (principal, principal, principal, opt nat, opt nat) -> Invoice
