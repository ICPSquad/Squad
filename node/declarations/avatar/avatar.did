type UserData = 
 record {
   account_identifier: opt text;
   discord: opt text;
   email: opt text;
   height: opt nat64;
   invoice_id: opt nat;
   minted: bool;
   name: opt Name__1;
   rank: opt nat64;
   selected_avatar: opt TokenIdentifier__2;
   twitter: opt text;
 };
type User = 
 variant {
   address: AccountIdentifier;
   "principal": principal;
 };
type UpdateCallsAggregatedData = vec nat64;
type TransferResponse = 
 variant {
   err:
    variant {
      CannotNotify: AccountIdentifier;
      InsufficientBalance;
      InvalidToken: TokenIdentifier__1;
      Other: text;
      Rejected;
      Unauthorized: AccountIdentifier;
    };
   ok: Balance;
 };
type TransferRequest = 
 record {
   amount: Balance;
   from: User;
   memo: Memo;
   notify: bool;
   subaccount: opt SubAccount;
   to: User;
   token: TokenIdentifier__1;
 };
type TokenIndex = nat32;
type TokenIdentifier__2 = text;
type TokenIdentifier__1 = text;
type TokenIdentifier = text;
type Time = int;
type Tag = text;
type SubAccount = vec nat8;
type StyleScore = nat;
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback: StreamingCallback;
                              token: StreamingCallbackToken;
                            };};
type StreamingCallbackToken = 
 record {
   content_encoding: text;
   index: nat;
   key: text;
 };
type StreamingCallbackResponse = 
 record {
   body: blob;
   token: opt StreamingCallbackToken;
 };
type StreamingCallback = func (StreamingCallbackToken) ->
                          (StreamingCallbackResponse) query;
type Stats = 
 vec record {
       Name;
       Stars;
     };
type Stars = nat;
type Result_6 = 
 variant {
   err: CommonError;
   ok: AccountIdentifier__1;
 };
type Result_5 = 
 variant {
   err: CommonError;
   ok: record {
         AccountIdentifier__1;
         opt Listing;
       };
 };
type Result_4 = 
 variant {
   err: CommonError__1;
   ok: Metadata;
 };
type Result_3 = 
 variant {
   err: CommonError;
   ok: vec TokenIndex;
 };
type Result_2 = 
 variant {
   err: CommonError;
   ok: vec record {
             TokenIndex;
             opt Listing;
             opt blob;
           };
 };
type Result_1 = 
 variant {
   err: CommonError;
   ok: vec TokenIdentifier;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type Response = 
 record {
   body: blob;
   headers: vec HeaderField;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
 };
type Request = 
 record {
   body: blob;
   headers: vec HeaderField;
   method: text;
   url: text;
 };
type NumericEntity = 
 record {
   avg: nat64;
   first: nat64;
   last: nat64;
   max: nat64;
   min: nat64;
 };
type Nanos = nat64;
type Name__2 = text;
type Name__1 = text;
type Name = text;
type MintResult = 
 variant {
   err: text;
   ok: TokenIdentifier;
 };
type MintInformation = 
 record {
   background: text;
   cloth: text;
   colors: Colors;
   ears: text;
   eyes: text;
   hair: text;
   mouth: text;
   nose: text;
   profile: text;
 };
type MetricsGranularity = 
 variant {
   daily;
   hourly;
 };
type Metadata = 
 variant {
   fungible:
    record {
      decimals: nat8;
      metadata: opt blob;
      name: text;
      symbol: text;
    };
   nonfungible: record {metadata: opt blob;};
 };
type Meta = 
 record {
   category: Category;
   description: text;
   name: text;
   tags: vec Tag;
 };
type Memo = blob;
type LogMessagesData = 
 record {
   message: text;
   timeNanos: Nanos;
 };
type Listing = 
 record {
   locked: opt Time;
   price: nat64;
   seller: principal;
   subaccount: opt SubAccount;
 };
type ICPSquadNFT = 
 service {
   acceptCycles: () -> ();
   add_admin: (principal) -> ();
   availableCycles: () -> (nat) query;
   balance: (BalanceRequest) -> (BalanceResponse) query;
   bearer: (TokenIdentifier) -> (Result_6) query;
   calculate_accounts: () -> ();
   calculate_style_score: () -> () oneway;
   changeStyle: (text) -> ();
   collectCanisterMetrics: () -> ();
   delete: (text) -> (Result);
   delete_admin: (principal) -> ();
   details: (TokenIdentifier) -> (Result_5) query;
   draw: (TokenIdentifier) -> (Result);
   eventsSize: () -> (nat) query;
   extensions: () -> (vec Extension) query;
   getCanisterLog: (opt CanisterLogRequest) ->
    (opt CanisterLogResponse) query;
   getCanisterMetrics: (GetMetricsParameters) -> (opt CanisterMetrics) query;
   getRegistry: () -> (vec record {
                             TokenIndex;
                             AccountIdentifier__1;
                           }) query;
   getTokens: () -> (vec record {
                           TokenIndex;
                           Metadata;
                         }) query;
   get_all_users: () -> (vec record {
                               principal;
                               UserData;
                             });
   get_infos_leaderboard: () ->
    (vec record {
           principal;
           opt Name__2;
           opt TokenIdentifier;
         }) query;
   get_style_score: () -> (vec record {
                                 TokenIdentifier;
                                 StyleScore;
                               }) query;
   get_user: () -> (opt UserData) query;
   http_request: (Request) -> (Response) query;
   init_cap: () -> (Result);
   is_admin: (principal) -> (bool) query;
   metadata: (TokenIdentifier) -> (Result_4) query;
   mint: (MintInformation, opt nat) -> (MintResult);
   modify_user: (UserData) -> (Result);
   registerComponent: (text, Component) -> (Result);
   removeAccessory: (TokenIdentifier, text, principal) -> (Result);
   supply: () -> (nat) query;
   tokens: (AccountIdentifier__1) -> (Result_3) query;
   tokens_ext: (AccountIdentifier__1) -> (Result_2) query;
   tokens_id: (AccountIdentifier__1) -> (Result_1) query;
   transfer: (TransferRequest) -> (TransferResponse);
   upload: (vec nat8) -> ();
   uploadClear: () -> ();
   uploadFinalize: (text, Meta, text) -> (Result);
   uploadStats: (Stats) -> () oneway;
   verificationEvents: () -> ();
   wearAccessory: (TokenIdentifier, text, principal) -> (Result);
 };
type HourlyMetricsData = 
 record {
   canisterCycles: CanisterCyclesAggregatedData;
   canisterHeapMemorySize: CanisterHeapMemoryAggregatedData;
   canisterMemorySize: CanisterMemoryAggregatedData;
   timeMillis: int;
   updateCalls: UpdateCallsAggregatedData;
 };
type HeaderField = 
 record {
   text;
   text;
 };
type GetMetricsParameters = 
 record {
   dateFromMillis: nat;
   dateToMillis: nat;
   granularity: MetricsGranularity;
 };
type GetLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   fromTimeNanos: opt Nanos;
 };
type GetLogMessagesFilter = 
 record {
   analyzeCount: nat32;
   messageContains: opt text;
   messageRegex: opt text;
 };
type GetLatestLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   upToTimeNanos: opt Nanos;
 };
type Extension = text;
type DailyMetricsData = 
 record {
   canisterCycles: NumericEntity;
   canisterHeapMemorySize: NumericEntity;
   canisterMemorySize: NumericEntity;
   timeMillis: int;
   updateCalls: nat64;
 };
type ComponentCategory = 
 variant {
   Accessory;
   Avatar;
   Other;
 };
type Component = 
 record {
   category: ComponentCategory;
   layers: vec nat;
   name: text;
 };
type CommonError__1 = 
 variant {
   InvalidToken: TokenIdentifier__1;
   Other: text;
 };
type CommonError = 
 variant {
   InvalidToken: TokenIdentifier__1;
   Other: text;
 };
type Colors = 
 vec record {
       color: Color;
       spot: text;
     };
type Color = 
 record {
   nat8;
   nat8;
   nat8;
   nat8;
 };
type Category = 
 variant {
   AccessoryComponent;
   AvatarComponent;
   LegendaryCharacter;
 };
type CanisterMetricsData = 
 variant {
   daily: vec DailyMetricsData;
   hourly: vec HourlyMetricsData;
 };
type CanisterMetrics = record {data: CanisterMetricsData;};
type CanisterMemoryAggregatedData = vec nat64;
type CanisterLogResponse = 
 variant {
   messages: CanisterLogMessages;
   messagesInfo: CanisterLogMessagesInfo;
 };
type CanisterLogRequest = 
 variant {
   getLatestMessages: GetLatestLogMessagesParameters;
   getMessages: GetLogMessagesParameters;
   getMessagesInfo;
 };
type CanisterLogMessagesInfo = 
 record {
   count: nat32;
   features: vec opt CanisterLogFeature;
   firstTimeNanos: opt Nanos;
   lastTimeNanos: opt Nanos;
 };
type CanisterLogMessages = 
 record {
   data: vec LogMessagesData;
   lastAnalyzedMessageTimeNanos: opt Nanos;
 };
type CanisterLogFeature = 
 variant {
   filterMessageByContains;
   filterMessageByRegex;
 };
type CanisterHeapMemoryAggregatedData = vec nat64;
type CanisterCyclesAggregatedData = vec nat64;
type BalanceResponse = 
 variant {
   err: CommonError__1;
   ok: Balance;
 };
type BalanceRequest = 
 record {
   token: TokenIdentifier__1;
   user: User;
 };
type Balance = nat;
type AccountIdentifier__1 = text;
type AccountIdentifier = text;
service : (principal, principal, principal, principal) -> ICPSquadNFT
